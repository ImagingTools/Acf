/**
\page page_ilog ilog - Logging Library

\section intro_sec Introduction

The ilog library provides a comprehensive, component-based logging framework for the ACF (Application 
Component Framework). It offers flexible message handling, multiple output targets, hierarchical message 
organization, and extensible message consumers. The library is designed for system-independent logging 
with support for severity levels, message filtering, tracing, and both synchronous and asynchronous 
message delivery.

\section features_sec Key Features

- **Structured Message System**: Type-safe message objects with category, ID, timestamp, and source information
- **Message Consumer Architecture**: Pluggable consumers for flexible message routing and processing
- **Console Logging**: Colored console output with customizable formatting
- **Message Containers**: Storage and retrieval of messages with hierarchical organization
- **Extended Messages**: Rich message objects with attached custom data and metadata
- **Component Integration**: Seamless integration with ACF component framework
- **Tracing Support**: Configurable tracing levels for verbose diagnostic output
- **Stream Bridging**: Redirect standard output/error streams to logging system
- **Log Routing**: Forward messages between different logging components based on severity
- **Thread-Safe Operations**: Qt signal-slot based asynchronous message handling
- **Serialization**: Full support for message persistence and loading

\section architecture_sec Architecture

The ilog library is organized into several layers:

\subsection core_interfaces Core Interfaces

\subsubsection message_consumer IMessageConsumer
The fundamental interface for consuming log messages:
- **ilog::IMessageConsumer**: Base interface for all message consumers
  - `IsMessageSupported()`: Check if a message type/category is accepted
  - `AddMessage()`: Add a message to the consumer

\subsubsection message_container IMessageContainer
Interface for storing and managing collections of messages:
- **ilog::IMessageContainer**: Container interface with message retrieval
  - `GetMessages()`: Retrieve all stored messages
  - `ClearMessages()`: Remove all messages from container
  - `GetWorstCategory()`: Get highest severity level of stored messages
- **ilog::IHierarchicalMessageContainer**: Hierarchical container support

\subsubsection loggable ILoggable
Interface for objects that can have a log consumer attached:
- **ilog::ILoggable**: Provides log attachment capability
  - `SetLogPtr()`: Attach a message consumer
  - `GetLogPtr()`: Retrieve attached consumer

\subsubsection tracing ITracingConfiguration
Interface for configuring tracing verbosity:
- **ilog::ITracingConfiguration**: Control tracing levels
  - `GetTracingLevel()`: Get current tracing level (-1=off, 0=all)
  - `SetTracingLevel()`: Set tracing level

\subsection message_classes Message Classes

\subsubsection basic_message CMessage
Basic implementation of information provider interface:
- **ilog::CMessage**: Fundamental message class implementing istd::IInformationProvider
  - Stores category, ID, text, source, flags, and timestamp
  - Implements serialization for persistence
  - Supports cloning and copying

\subsubsection extended_message CExtMessage
Extended message with attached objects:
- **ilog::CExtMessage**: Message with attached serializable objects
  - Inherits from CMessage
  - Can attach multiple IObject instances with descriptions
  - Useful for passing complex data with log messages

\subsubsection template_message TExtMessage
Template-based extended message:
- **ilog::TExtMessage<Element>**: Template for creating custom message types
  - Combines CMessage with user-defined Element type
  - Automatic serialization of both parts
  - Type-safe message specialization

\subsection logging_components Logging Components

\subsubsection log_comp_base CLogCompBase
Base class for logging components with event queue:
- **ilog::CLogCompBase**: Threadsafe logging using Qt signals/slots
  - Inherits from QObject and TMessageDelegatorComp
  - Asynchronous message delivery via EmitAddMessage signal
  - Delegates messages to slave consumer
  - Abstract WriteMessageToLog() for derived implementations

\subsubsection log_comp CLogComp
Standard logging component with message storage:
- **ilog::CLogComp**: Complete logging component with message container
  - Inherits from CLogCompBase and CMessageContainer
  - Configurable maximum message count
  - Automatic message pruning when limit exceeded
  - Supports message serialization
  - Provides IMessageContainer interface

\subsubsection stream_log_base CStreamLogCompBase
Base class for stream-based logging:
- **ilog::CStreamLogCompBase**: Foundation for text stream logging
  - Configurable minimum severity level filtering
  - Optional dot display for filtered messages
  - Customizable message formatting (category, code, timestamp)
  - Time format configuration
  - Tracks worst category encountered
  - Abstract WriteText() for output implementation

\subsubsection console_log CConsoleLogComp
Console output with color support:
- **ilog::CConsoleLogComp**: Colored console logging
  - Platform-specific color support (Windows/Unix)
  - Severity-based coloring (error=red, warning=yellow, info=default)
  - Writes to std::wcout
  - Inherits all CStreamLogCompBase features

\subsection utility_components Utility Components

\subsubsection log_router CLogRouterComp
Routes messages between containers:
- **ilog::CLogRouterComp**: Observes source container and forwards messages
  - Monitors IMessageContainer for new messages
  - Filters by minimum severity category
  - Prevents duplicate message forwarding
  - Integrates with model-observer pattern

\subsubsection stream_bridge CStandardStreamBridge
Bridges C++ streams to logging:
- **ilog::CStandardStreamBridge**: Redirects std::cout/std::cerr
  - Inherits from std::basic_streambuf
  - Converts stream output to log messages
  - Restores original stream buffer on destruction
  - Thread-safe with mutex protection

\subsubsection stream_bridge_comp CStandardStreamBridgeComp
Component wrapper for stream bridging:
- **ilog::CStandardStreamBridgeComp**: Manages stream bridges as component
  - Creates bridges for both cout and cerr
  - Configurable message severity per stream
  - Automatic cleanup on component destruction

\subsubsection tracing_config CTracingConfigurationComp
Tracing level configuration:
- **ilog::CTracingConfigurationComp**: Manages tracing verbosity
  - Implements ITracingConfiguration interface
  - Configurable default tracing level
  - Serialization support for persistence
  - Component-based configuration

\subsection base_classes Base Classes

\subsubsection logger_base CLoggerBase
Foundation for logging functionality:
- **ilog::CLoggerBase**: Implements ILogger via IMessageConsumer
  - Convenience methods: SendInfoMessage, SendWarningMessage, SendErrorMessage, SendCriticalMessage
  - "Send once" variants to prevent message duplication
  - Message decoration hook (DecorateMessage)
  - Log consumption checking (IsLogConsumed)
  - Manages attached IMessageConsumer

\subsubsection message_container_impl CMessageContainer
Message storage implementation:
- **ilog::CMessageContainer**: Full-featured message container
  - Implements IMessageContainer and IMessageConsumer
  - Hierarchical container support
  - Configurable maximum message count
  - Slave consumer delegation
  - Message type registration for serialization
  - Thread-safe operations
  - Worst category tracking

\subsection template_classes Template Classes

\subsubsection logger_comp_wrap TLoggerCompWrap
Logger functionality for components:
- **ilog::TLoggerCompWrap<Base>**: Adds logging to any component
  - Inherits from Base and CLoggerBase
  - Automatic log consumer connection from "Log" reference
  - Verbose message support with tracing level
  - Component ID decoration of message sources
  - Type alias: CLoggerComponentBase for simple components

\subsubsection message_delegator TMessageDelegatorComp
Message delegation component:
- **ilog::TMessageDelegatorComp<BaseComponent>**: Forwards messages
  - Implements IMessageConsumer interface
  - Delegates all messages to slave consumer
  - Component-based message routing
  - Configurable via "SlaveMessageConsumer" reference

\section usage_sec Usage Examples

\subsection example_basic_logging Basic Logging

\code{.cpp}
#include <ilog/CLogComp.h>
#include <ilog/CConsoleLogComp.h>
#include <ilog/CMessage.h>

// Create console logger
istd::TSharedInterfacePtr<ilog::CConsoleLogComp> consoleLog(new ilog::CConsoleLogComp);

// Create a message
istd::TSharedInterfacePtr<ilog::CMessage> message(
    new ilog::CMessage(
        istd::IInformationProvider::IC_INFO,
        1001,
        "Application started successfully",
        "MyApplication"
    )
);

// Send message to console
consoleLog->AddMessage(message);
\endcode

\subsection example_component_logging Component-Based Logging

\code{.cpp}
#include <ilog/TLoggerCompWrap.h>

// Create a component with logging capability
class MyComponent : public ilog::CLoggerComponentBase
{
public:
    void DoWork()
    {
        // Send different severity messages
        SendInfoMessage(2001, "Starting work", "MyComponent::DoWork");
        
        try {
            // ... do work ...
            SendInfoMessage(2002, "Work completed", "MyComponent::DoWork");
        }
        catch (const std::exception& e) {
            SendErrorMessage(2003, 
                QString("Work failed: %1").arg(e.what()),
                "MyComponent::DoWork");
        }
    }
    
    void VerboseOperation()
    {
        // Only logged if verbose is enabled
        SendVerboseMessage("Detailed diagnostic information", 
                          "MyComponent::VerboseOperation");
    }
};
\endcode

\subsection example_message_container Message Container Usage

\code{.cpp}
#include <ilog/CLogComp.h>
#include <ilog/CMessageContainer.h>

// Create log component (which includes message container)
istd::TSharedInterfacePtr<ilog::CLogComp> logComp(new ilog::CLogComp);

// Add messages
logComp->AddMessage(istd::TSharedInterfacePtr<ilog::CMessage>(
    new ilog::CMessage(istd::IInformationProvider::IC_WARNING, 
                      3001, "Low memory warning", "System")));

logComp->AddMessage(istd::TSharedInterfacePtr<ilog::CMessage>(
    new ilog::CMessage(istd::IInformationProvider::IC_ERROR, 
                      3002, "File not found", "FileSystem")));

// Retrieve all messages
ilog::IMessageContainer::Messages messages = logComp->GetMessages();
for (const auto& msgPtr : messages) {
    qDebug() << msgPtr->GetInformationDescription();
}

// Check worst category
istd::IInformationProvider::InformationCategory worst = 
    logComp->GetWorstCategory();
if (worst >= istd::IInformationProvider::IC_ERROR) {
    qDebug() << "Errors were logged!";
}

// Clear all messages
logComp->ClearMessages();
\endcode

\subsection example_extended_message Extended Messages with Attachments

\code{.cpp}
#include <ilog/CExtMessage.h>
#include <iser/IObjectFactory.h>

// Create extended message
istd::TSharedInterfacePtr<ilog::CExtMessage> extMsg(
    new ilog::CExtMessage(
        istd::IInformationProvider::IC_ERROR,
        4001,
        "Data validation failed",
        "Validator",
        0,
        nullptr,
        myObjectFactory  // Factory for deserialization
    )
);

// Attach custom objects
istd::TSharedInterfacePtr<iser::IObject> dataObject(new MyDataObject);
extMsg->InsertAttachedObject(dataObject.PopPtr(), "Invalid data sample");

istd::TSharedInterfacePtr<iser::IObject> contextObject(new MyContextObject);
extMsg->InsertAttachedObject(contextObject.PopPtr(), "Validation context");

// Access attached objects later
int count = extMsg->GetAttachedObjectsCount();
for (int i = 0; i < count; ++i) {
    const iser::IObject* objPtr = extMsg->GetAttachedObject(i);
    const QString& desc = extMsg->GetAttachedObjectDescription(i);
    qDebug() << "Attachment" << i << ":" << desc;
}
\endcode

\subsection example_stream_formatting Custom Stream Formatting

\code{.cpp}
#include <ilog/CConsoleLogComp.h>

// Create console log with custom formatting
istd::TSharedInterfacePtr<ilog::CConsoleLogComp> console(
    new ilog::CConsoleLogComp);

// Configure via component attributes (typically in .acfc file)
// MinCategory: 2 (warnings and above)
// UseCategory: true (show "Warning:", "Error:", etc.)
// UseCode: true (show message ID)
// UseTimeStamp: true (show timestamp)
// TimeFormat: "hh:mm:ss.zzz" (custom time format)
// ShowDots: true (show dots for filtered messages)

// Messages below warning level will show as "." if ShowDots=true
// Output format: "[12:34:56.789] Warning (5001): Low disk space - DiskMonitor"
\endcode

\subsection example_log_routing Message Routing Between Logs

\code{.cpp}
#include <ilog/CLogComp.h>
#include <ilog/CLogRouterComp.h>
#include <ilog/CConsoleLogComp.h>

// Create source log
istd::TSharedInterfacePtr<ilog::CLogComp> sourceLog(new ilog::CLogComp);

// Create destination logs
istd::TSharedInterfacePtr<ilog::CConsoleLogComp> consoleLog(
    new ilog::CConsoleLogComp);
istd::TSharedInterfacePtr<ilog::CLogComp> errorLog(new ilog::CLogComp);

// Create router for errors only
istd::TSharedInterfacePtr<ilog::CLogRouterComp> errorRouter(
    new ilog::CLogRouterComp);
// Configure: InputMessageContainer -> sourceLog
//           OutputMessageConsumer -> errorLog
//           MinimalCategory -> IC_ERROR

// Messages sent to sourceLog will be automatically forwarded
// to errorLog if they are errors or critical
sourceLog->AddMessage(/* ... */);
\endcode

\subsection example_stream_bridge Standard Stream Bridging

\code{.cpp}
#include <ilog/CStandardStreamBridgeComp.h>
#include <ilog/CConsoleLogComp.h>
#include <iostream>

// Create log destination
istd::TSharedInterfacePtr<ilog::CConsoleLogComp> logComp(
    new ilog::CConsoleLogComp);

// Create bridge component
istd::TSharedInterfacePtr<ilog::CStandardStreamBridgeComp> bridge(
    new ilog::CStandardStreamBridgeComp);
// Configure: SlaveMessageConsumer -> logComp

// Now std::cout and std::cerr are redirected
std::cout << "This goes to log as INFO" << std::endl;
std::cerr << "This goes to log as ERROR" << std::endl;

// Bridge is destroyed when component is destroyed, restoring streams
\endcode

\subsection example_tracing Tracing Configuration

\code{.cpp}
#include <ilog/TLoggerCompWrap.h>
#include <ilog/CTracingConfigurationComp.h>

class MyComponent : public ilog::CLoggerComponentBase
{
public:
    void AnalyzeData()
    {
        // Level 0 tracing (always shown when tracing enabled)
        SendVerboseMessage("Starting analysis", QString(), 0);
        
        // Level 1 tracing (more detailed)
        if (IsVerboseEnabled(1)) {
            SendVerboseMessage("Processing phase 1", QString(), 1);
        }
        
        // Level 2 tracing (very detailed)
        if (IsVerboseEnabled(2)) {
            SendVerboseMessage("Detailed step information", QString(), 2);
        }
    }
};

// In configuration:
// Component has reference: TracingConfiguration -> tracingConfig
// TracingConfiguration component has: DefaulTracingtLevel = 1
// This enables tracing levels 0 and 1, but not 2
\endcode

\subsection example_message_once Preventing Duplicate Messages

\code{.cpp}
#include <ilog/CLoggerBase.h>

class MyComponent : public ilog::CLoggerBase
{
public:
    void FrequentOperation()
    {
        // This message is only sent the first time
        SendWarningMessageOnce(7001, 
            "Performance degraded, consider optimization",
            "MyComponent");
        
        // ... operation that might be called many times ...
    }
    
    void Reset()
    {
        // Allow the message to be sent again
        AllowMessageOnceAgain(7001);
    }
};
\endcode

\subsection example_custom_message_type Custom Message Types

\code{.cpp}
#include <ilog/TExtMessage.h>

// Define custom data structure
struct DiagnosticData : public iser::ISerializable
{
    double cpuUsage;
    qint64 memoryUsed;
    
    virtual bool Serialize(iser::IArchive& archive) override {
        return archive.Process(cpuUsage, "cpu") &&
               archive.Process(memoryUsed, "memory");
    }
};

// Create message type combining CMessage and DiagnosticData
typedef ilog::TExtMessage<DiagnosticData> DiagnosticMessage;

// Register for serialization
I_REGISTER_MESSAGE_TYPE(DiagnosticMessage, "DiagnosticMessage");

// Use custom message
istd::TSharedInterfacePtr<DiagnosticMessage> diagMsg(
    new DiagnosticMessage(
        istd::IInformationProvider::IC_INFO,
        8001,
        "System diagnostics",
        "Monitor"
    )
);
diagMsg->cpuUsage = 45.2;
diagMsg->memoryUsed = 1024*1024*512; // 512 MB
\endcode

\section threading_sec Thread Safety

The ilog library uses several mechanisms to ensure thread-safe operation:

- **CLogCompBase**: Uses Qt signals/slots for thread-safe message delivery across thread boundaries
- **CStandardStreamBridge**: Uses QMutex to protect internal buffer during stream operations
- **Message Objects**: Individual message objects (CMessage, CExtMessage) are immutable after creation
- **Shared Pointers**: TSharedInterfacePtr ensures thread-safe reference counting

\warning Message containers (CMessageContainer) are not inherently thread-safe for concurrent 
modifications. Use appropriate synchronization when accessing from multiple threads, or use 
CLogCompBase which provides thread-safe message addition via signals.

\section serialization_sec Serialization

The ilog library fully supports serialization of messages:

- **CMessage**: Serializes all message properties (category, ID, text, source, flags, timestamp)
- **CExtMessage**: Serializes base message plus attached objects
- **TExtMessage<T>**: Serializes both message and custom element
- **CMessageContainer**: Can serialize entire message collections
- **Message Type Registration**: Use RegisterMessageType() or I_REGISTER_MESSAGE_TYPE macro

\code{.cpp}
// Register custom message type for serialization
bool registered = ilog::CMessageContainer::RegisterMessageType<MyCustomMessage>(
    "com.myapp.MyCustomMessage");

// Or use macro for automatic registration
I_REGISTER_MESSAGE_TYPE(MyCustomMessage, "com.myapp.MyCustomMessage");

// Serialization is then automatic via IMessageContainer
\endcode

\section dependencies_sec Dependencies

The ilog library depends on:
- **istd**: Standard utilities (IChangeable, IInformationProvider, ILogger, smart pointers)
- **iser**: Serialization framework (ISerializable, IObject, IArchive)
- **icomp**: Component framework (CComponentBase, IComponent)
- **imod**: Model-observer pattern (IModel, IObserver)
- **Qt Core**: QString, QDateTime, QByteArray, QObject, signals/slots
- **Qt Widgets**: (Optional, for some implementations)
- **C++ STL**: iostream, streambuf for stream bridging

\section best_practices_sec Best Practices

-# **Use Component-Based Logging**: Prefer TLoggerCompWrap for components to get integrated logging
-# **Assign Unique Message IDs**: Use unique IDs for each message type for filtering and processing
-# **Include Message Source**: Always provide source information for easier debugging
-# **Choose Appropriate Severity**: Use IC_INFO for informational, IC_WARNING for warnings, 
   IC_ERROR for errors, IC_CRITICAL for critical failures
-# **Use Message Containers**: Store messages in CLogComp for later analysis and export
-# **Configure Maximum Messages**: Set reasonable limits to prevent memory issues in long-running apps
-# **Leverage Hierarchical Containers**: Use child containers to organize messages by subsystem
-# **Use SendOnce Variants**: Prevent log spam from repeated messages in loops or frequent operations
-# **Enable Tracing Selectively**: Use tracing levels to control verbose output granularity
-# **Test with Stream Bridge**: CStandardStreamBridgeComp helps capture legacy code output
-# **Format Consistently**: Configure stream loggers with consistent time formats and message structure
-# **Route by Severity**: Use CLogRouterComp to separate errors from general logs
-# **Attach Context with CExtMessage**: For complex errors, attach relevant objects for debugging
-# **Implement Custom Decorators**: Override DecorateMessage() to add application-specific formatting
-# **Handle Asynchronous Delivery**: Remember CLogCompBase delivers messages asynchronously via events

\section see_also_sec See Also

\subsection interfaces_ref Interfaces
- ilog::IMessageConsumer
- ilog::IMessageContainer
- ilog::ILoggable
- ilog::ITracingConfiguration

\subsection messages_ref Message Classes
- ilog::CMessage
- ilog::CExtMessage
- ilog::TExtMessage

\subsection components_ref Logging Components
- ilog::CLogComp
- ilog::CConsoleLogComp
- ilog::CLogCompBase
- ilog::CStreamLogCompBase
- ilog::CLogRouterComp
- ilog::CStandardStreamBridgeComp
- ilog::CTracingConfigurationComp

\subsection base_ref Base Classes
- ilog::CLoggerBase
- ilog::CMessageContainer

\subsection templates_ref Template Classes
- ilog::TLoggerCompWrap
- ilog::TMessageDelegatorComp

*/
