name: Auto-Fix on Build Failure

on:
  workflow_run:
    workflows: ["TeamCity CI"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto-fix:
    name: Attempt Auto-Fix
    runs-on: ubuntu-latest
    # Only run on failed builds from pull requests in the same repository (not forks)
    # This allows the workflow to run automatically without requiring approval
    if: |
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.head_repository.full_name == github.repository
    steps:
      - name: Get PR Information
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            if (pulls.data.length === 0) {
              console.log('No open PR found for this branch');
              return null;
            }
            const pr = pulls.data[0];
            console.log(`Found PR #${pr.number}: ${pr.title}`);
            return {
              number: pr.number,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref
            };

      - name: Checkout PR branch
        if: steps.pr.outputs.result != 'null'
        uses: actions/checkout@v6
        with:
          ref: ${{ fromJSON(steps.pr.outputs.result).head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Analyze Build Failure
        if: steps.pr.outputs.result != 'null'
        id: analyze
        env:
          TEAMCITY_URL: ${{ vars.TEAMCITY_URL }}
          TEAMCITY_TOKEN: ${{ vars.TEAMCITY_TOKEN }}
        shell: bash
        run: |
          echo "Analyzing build failure patterns..."
          
          # Initialize variables
          issue_type="unknown"
          fix_available="false"
          build_problems=""
          build_ids=""
          
          # Check if TeamCity configuration is available
          if [ -z "${TEAMCITY_URL:-}" ] || [ -z "${TEAMCITY_TOKEN:-}" ]; then
            echo "âš ï¸ TeamCity configuration not available - cannot fetch detailed build errors"
            echo "Will skip detailed analysis"
          else
            echo "Fetching build problems from TeamCity..."
            
            # Get the workflow run that triggered this auto-fix
            WORKFLOW_RUN_ID="${{ github.event.workflow_run.id }}"
            
            # Get jobs from the triggering workflow run
            JOBS_RESPONSE=$(curl -sS \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs")
            
            # Extract TeamCity build IDs from job steps
            echo "Extracting TeamCity build IDs from workflow jobs..."
            
            # Fetch job logs to extract build IDs if available
            JOB_IDS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[] | select(.conclusion == "failure") | .id')
            
            TEAMCITY_BUILD_IDS=""
            for JOB_ID in $JOB_IDS; do
              echo "Checking job $JOB_ID for TeamCity build IDs..."
              JOB_LOGS=$(curl -sS \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${{ github.repository }}/actions/jobs/$JOB_ID/logs" 2>/dev/null || echo "")
              
              # Extract build IDs from logs
              # NOTE: This pattern matches the output format from teamcity-trigger.yml line 130:
              # "âœ… Build queued. ID=$BUILD_ID"
              # If the log format in teamcity-trigger.yml changes, update this pattern accordingly
              EXTRACTED_IDS=$(echo "$JOB_LOGS" | grep -oP "Build queued\. ID=\K\d+" || echo "")
              if [ -n "$EXTRACTED_IDS" ]; then
                TEAMCITY_BUILD_IDS="$TEAMCITY_BUILD_IDS $EXTRACTED_IDS"
              fi
            done
            
            TEAMCITY_BUILD_IDS=$(echo "$TEAMCITY_BUILD_IDS" | xargs)
            echo "Found TeamCity build IDs: $TEAMCITY_BUILD_IDS"
            build_ids="$TEAMCITY_BUILD_IDS"
            
            # Fetch detailed build problems from TeamCity for each build ID
            ALL_PROBLEMS_JSON="[]"
            if [ -n "$TEAMCITY_BUILD_IDS" ]; then
              for BUILD_ID in $TEAMCITY_BUILD_IDS; do
                echo "Fetching problems for TeamCity build $BUILD_ID..."
                
                PROBLEMS_RESPONSE=$(curl -sS \
                  -H "Authorization: Bearer $TEAMCITY_TOKEN" \
                  -H "Accept: application/json" \
                  "$TEAMCITY_URL/app/rest/builds/id:$BUILD_ID/problemOccurrences?fields=problemOccurrence(id,type,identity,details,additionalData,build(id,buildTypeId,webUrl,branchName))" 2>/dev/null || echo '{}')
                
                PROBLEM_COUNT=$(echo "$PROBLEMS_RESPONSE" | jq -r '.count // 0')
                echo "Found $PROBLEM_COUNT problem(s) for build $BUILD_ID"
                
                if [ "$PROBLEM_COUNT" -gt 0 ]; then
                  # Add build problems to collection
                  PROBLEMS_ARRAY=$(echo "$PROBLEMS_RESPONSE" | jq -r '.problemOccurrence // []')
                  ALL_PROBLEMS_JSON=$(echo "$ALL_PROBLEMS_JSON" | jq --argjson new "$PROBLEMS_ARRAY" '. + $new')
                  issue_type="build_failure"
                fi
              done
            else
              echo "No TeamCity build IDs found - falling back to job name analysis"
              # Extract build problem information from the jobs as fallback
              FAILED_JOBS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[]? | select(.conclusion == "failure") | .name' || echo "")
              
              if [ -n "$FAILED_JOBS" ]; then
                echo "Found failed jobs: $FAILED_JOBS"
                build_problems="$FAILED_JOBS"
                
                # Check for common patterns in job names
                if echo "$FAILED_JOBS" | grep -qi "linux\|windows"; then
                  echo "Detected platform-specific build failure"
                  issue_type="build_failure"
                fi
              fi
            fi
            
            # Save all problems as JSON for the next step
            if [ "$(echo "$ALL_PROBLEMS_JSON" | jq '. | length')" -gt 0 ]; then
              echo "Total problems collected: $(echo "$ALL_PROBLEMS_JSON" | jq '. | length')"
              build_problems="$ALL_PROBLEMS_JSON"
            fi
          fi
          
          echo "issue_type=$issue_type" >> "$GITHUB_OUTPUT"
          echo "fix_available=$fix_available" >> "$GITHUB_OUTPUT"
          echo "build_ids=$build_ids" >> "$GITHUB_OUTPUT"
          echo "BUILD_PROBLEMS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$build_problems" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "Build failure analysis complete"

      - name: Attempt Common Fixes
        if: steps.pr.outputs.result != 'null'
        id: fix
        shell: bash
        run: |
          echo "Checking for common fixable issues..."
          CHANGES_MADE=false
          
          # Get build problems from analyze step
          BUILD_PROBLEMS="${{ steps.analyze.outputs.BUILD_PROBLEMS }}"
          ISSUE_TYPE="${{ steps.analyze.outputs.issue_type }}"
          
          if [ -n "$BUILD_PROBLEMS" ]; then
            echo "Build problems detected:"
            echo "$BUILD_PROBLEMS"
            echo ""
            echo "Issue type: $ISSUE_TYPE"
            
            # In future: Add actual fix logic here based on issue_type
            # For now, we just recognize that errors exist
            echo "Auto-fix logic not yet implemented for detected issues"
            echo "This workflow now successfully recognizes build errors"
          else
            echo "No specific build problems to fix"
          fi
          
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

      - name: Create Copilot Tasks for Build Problems
        if: steps.pr.outputs.result != 'null' && steps.analyze.outputs.issue_type != 'unknown'
        id: create_tasks
        uses: actions/github-script@v7
        with:
          script: |
            const prInfo = JSON.parse('${{ steps.pr.outputs.result }}');
            const buildProblemsRaw = `${{ steps.analyze.outputs.BUILD_PROBLEMS }}`;
            const buildIds = '${{ steps.analyze.outputs.build_ids }}';
            const issueType = '${{ steps.analyze.outputs.issue_type }}';
            
            let createdIssues = [];
            
            // Try to parse build problems as JSON (from TeamCity)
            let buildProblems = [];
            try {
              const parsed = JSON.parse(buildProblemsRaw);
              if (Array.isArray(parsed) && parsed.length > 0) {
                buildProblems = parsed;
                console.log(`Parsed ${buildProblems.length} build problem(s) from TeamCity`);
              }
            } catch (e) {
              console.log('Build problems is not JSON array, treating as plain text');
            }
            
            if (buildProblems.length > 0) {
              // Create issues for TeamCity build problems
              for (const problem of buildProblems) {
                const problemType = problem.type || 'Unknown';
                const problemIdentity = problem.identity || 'Unknown issue';
                const problemDetails = problem.details || 'No details available';
                const buildInfo = problem.build || {};
                const buildUrl = buildInfo.webUrl || '';
                const buildId = buildInfo.id || '';
                const branchName = buildInfo.branchName || prInfo.head_ref;
                
                // Create a descriptive title
                let title = `[Auto-Fix] ${problemType}: ${problemIdentity}`;
                if (title.length > 100) {
                  title = title.substring(0, 97) + '...';
                }
                
                // Create detailed issue body
                let body = `## Build Problem Detected\n\n`;
                body += `**Type:** ${problemType}\n`;
                body += `**Identity:** ${problemIdentity}\n`;
                body += `**Branch:** ${branchName}\n`;
                body += `**PR:** #${prInfo.number}\n\n`;
                
                if (buildUrl) {
                  body += `**TeamCity Build:** [Build ${buildId}](${buildUrl})\n\n`;
                }
                
                body += `### Problem Details\n\`\`\`\n${problemDetails}\n\`\`\`\n\n`;
                
                body += `### Context\n`;
                body += `This issue was automatically created by the auto-fix workflow after detecting a build failure.\n\n`;
                
                body += `### Task for Copilot\n`;
                body += `Please analyze the build problem and:\n`;
                body += `1. Identify the root cause of the issue\n`;
                body += `2. Implement a fix for the problem\n`;
                body += `3. Ensure the fix doesn't break existing functionality\n`;
                body += `4. Test the changes to verify the build passes\n\n`;
                
                body += `**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\n`;
                body += `**Original Build Failure:** ${{ github.event.workflow_run.html_url }}`;
                
                try {
                  const issue = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: body,
                    labels: ['auto-fix', 'build-failure', 'copilot-task'],
                    assignees: []  // Copilot will be assigned via labels
                  });
                  
                  console.log(`âœ… Created issue #${issue.data.number}: ${title}`);
                  createdIssues.push(issue.data.number);
                } catch (error) {
                  console.error(`Failed to create issue for problem: ${error.message}`);
                }
              }
              
              core.setOutput('created_issues', createdIssues.join(','));
              core.setOutput('issues_count', createdIssues.length);
              console.log(`\nðŸ“‹ Created ${createdIssues.length} issue(s) for Copilot: ${createdIssues.join(', ')}`);
            } else if (buildProblemsRaw && buildProblemsRaw.trim() !== '') {
              // Fallback: create a single generic issue for text-based problems
              console.log('Creating generic issue from text-based build problems');
              
              const title = `[Auto-Fix] Build Failure on ${prInfo.head_ref}`;
              let body = `## Build Failure Detected\n\n`;
              body += `**Branch:** ${prInfo.head_ref}\n`;
              body += `**PR:** #${prInfo.number}\n`;
              body += `**Issue Type:** ${issueType}\n\n`;
              
              body += `### Build Problems\n\`\`\`\n${buildProblemsRaw}\n\`\`\`\n\n`;
              
              body += `### Context\n`;
              body += `This issue was automatically created by the auto-fix workflow after detecting a build failure.\n\n`;
              
              body += `### Task for Copilot\n`;
              body += `Please analyze the build failure and:\n`;
              body += `1. Review the build logs and error messages\n`;
              body += `2. Identify the root cause of the failure\n`;
              body += `3. Implement a fix for the problem\n`;
              body += `4. Test the changes to verify the build passes\n\n`;
              
              body += `**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\n`;
              body += `**Original Build Failure:** ${{ github.event.workflow_run.html_url }}`;
              
              try {
                const issue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: ['auto-fix', 'build-failure', 'copilot-task'],
                  assignees: []
                });
                
                console.log(`âœ… Created generic issue #${issue.data.number}`);
                createdIssues.push(issue.data.number);
                
                core.setOutput('created_issues', createdIssues.join(','));
                core.setOutput('issues_count', createdIssues.length);
              } catch (error) {
                console.error(`Failed to create generic issue: ${error.message}`);
              }
            } else {
              console.log('No build problems to create issues for');
              core.setOutput('created_issues', '');
              core.setOutput('issues_count', 0);
            }

      - name: Commit and Push Fixes
        if: steps.fix.outputs.changes_made == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Auto-fix: Resolve build errors"
          git push

      - name: Comment on PR
        if: steps.pr.outputs.result != 'null'
        uses: actions/github-script@v7
        with:
          script: |
            const prInfo = JSON.parse('${{ steps.pr.outputs.result }}');
            const changesMade = '${{ steps.fix.outputs.changes_made }}' === 'true';
            const issueType = '${{ steps.analyze.outputs.issue_type }}';
            const createdIssues = '${{ steps.create_tasks.outputs.created_issues }}';
            const issuesCount = '${{ steps.create_tasks.outputs.issues_count }}' || '0';
            // Safely handle build problems - use toJSON for proper escaping
            const buildProblemsRaw = '${{ steps.analyze.outputs.BUILD_PROBLEMS }}';
            const buildProblems = buildProblemsRaw.replace(/[\u0000-\u001F\u007F-\u009F]/g, '').trim();

            let body;
            if (changesMade) {
              body = 'âœ… Auto-fix applied. Please review the changes.';
            } else {
              body = 'âš ï¸ Build failed. Auto-fix workflow has analyzed the failure.\n\n';
              
              if (buildProblems) {
                body += '**Detected Issues:**\n';
                body += '```\n' + buildProblems + '\n```\n\n';
                body += `**Issue Type:** ${issueType}\n\n`;
              }
              
              // Add information about created Copilot tasks
              if (issuesCount && parseInt(issuesCount) > 0) {
                body += `### ðŸ¤– Copilot Tasks Created\n`;
                body += `Created ${issuesCount} task(s) for Copilot to fix the detected problems.\n`;
                if (createdIssues) {
                  const issueNumbers = createdIssues.split(',').map(n => `#${n.trim()}`).join(', ');
                  body += `**Issues:** ${issueNumbers}\n\n`;
                }
                body += `Copilot will analyze the build failures and create fixes for these issues.\n\n`;
              }
              
              body += '**Status:** Build errors were recognized by the auto-fix workflow.\n';
              if (issuesCount && parseInt(issuesCount) > 0) {
                body += '**Action:** Copilot tasks have been created. You can also fix manually if needed.\n\n';
              } else {
                body += '**Action Required:** Manual fix needed. Auto-fix logic for these errors is not yet implemented.\n\n';
              }
              body += 'Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) and [build logs](${{ github.event.workflow_run.html_url }}) for details.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: body
            });
