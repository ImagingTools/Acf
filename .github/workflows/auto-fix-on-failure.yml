name: Auto-Fix on Build Failure

on:
  workflow_run:
    workflows: ["TeamCity CI"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto-fix:
    name: Attempt Auto-Fix
    runs-on: ubuntu-latest
    # Only run on failed builds from pull requests in the same repository (not forks)
    # This allows the workflow to run automatically without requiring approval
    if: |
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.head_repository.full_name == github.repository
    steps:
      - name: Get PR Information
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            if (pulls.data.length === 0) {
              console.log('No open PR found for this branch');
              return null;
            }
            const pr = pulls.data[0];
            console.log(`Found PR #${pr.number}: ${pr.title}`);
            return {
              number: pr.number,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref
            };

      - name: Wait for TeamCity Builds to Complete
        if: steps.pr.outputs.result != 'null'
        id: wait_checks
        uses: actions/github-script@v8
        with:
          script: |
            const prInfo = JSON.parse('${{ steps.pr.outputs.result }}');
            const headSha = prInfo.head_sha;
            
            console.log(`Waiting for TeamCity builds to complete for SHA: ${headSha}`);
            
            const maxAttempts = 60; // 60 attempts * 30 seconds = 30 minutes max
            const delayMs = 30000; // 30 seconds between checks
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              console.log(`\nAttempt ${attempt}/${maxAttempts}: Checking TeamCity build status...`);
              
              // Get all check runs for this commit
              const checkRuns = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
                per_page: 100
              });
              
              console.log(`Found ${checkRuns.data.total_count} check runs`);
              
              // Filter to only TeamCity checks
              const teamcityChecks = checkRuns.data.check_runs.filter(check => 
                check.name.includes('Trigger TeamCity Build')
              );
              
              console.log(`Found ${teamcityChecks.length} TeamCity check(s)`);
              
              if (teamcityChecks.length === 0) {
                console.log('⚠️ No TeamCity checks found - skipping auto-fix');
                return { proceed: false };
              }
              
              // Check if all TeamCity builds are completed
              const pendingTeamcityChecks = teamcityChecks.filter(check => 
                check.status !== 'completed'
              );
              
              if (pendingTeamcityChecks.length === 0) {
                console.log('✅ All TeamCity builds have completed');
                
                // Check if any TeamCity build failed
                const failedTeamcityChecks = teamcityChecks.filter(check => 
                  check.conclusion === 'failure'
                );
                
                if (failedTeamcityChecks.length > 0) {
                  console.log(`✅ ${failedTeamcityChecks.length} TeamCity build(s) failed - proceeding with auto-fix`);
                  for (const check of failedTeamcityChecks) {
                    console.log(`  - ${check.name}: ${check.conclusion}`);
                  }
                  return { proceed: true };
                } else {
                  console.log('⚠️ No TeamCity builds failed - skipping auto-fix');
                  return { proceed: false };
                }
              }
              
              console.log(`⏳ ${pendingTeamcityChecks.length} TeamCity build(s) still pending:`);
              for (const check of pendingTeamcityChecks) {
                console.log(`  - ${check.name}: ${check.status}`);
              }
              
              if (attempt < maxAttempts) {
                console.log(`Waiting ${delayMs/1000} seconds before next check...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
              }
            }
            
            console.log('❌ Timeout: Not all TeamCity builds completed within 30 minutes');
            return { proceed: false };

      - name: Skip Auto-Fix
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == false
        run: |
          echo "⚠️ Skipping auto-fix workflow"
          echo "Reason: Either TeamCity builds not completed, or no TeamCity builds failed"
          echo "See 'Wait for TeamCity Builds to Complete' step for details"

      - name: Checkout PR branch
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == true
        uses: actions/checkout@v6
        with:
          ref: ${{ fromJSON(steps.pr.outputs.result).head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Download TeamCity Build Info
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == true
        id: download_build_info
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: teamcity-build-info-*
          path: teamcity-build-info
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Analyze Build Failure
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == true
        id: analyze
        env:
          TEAMCITY_URL: ${{ vars.TEAMCITY_URL }}
          TEAMCITY_TOKEN: ${{ vars.TEAMCITY_TOKEN }}
        shell: bash
        run: |
          echo "Analyzing build failure patterns..."
          
          # Initialize variables
          issue_type="unknown"
          fix_available="false"
          build_problems=""
          build_ids=""
          build_log_summary=""
          
          # Check if TeamCity configuration is available
          if [ -z "${TEAMCITY_URL:-}" ] || [ -z "${TEAMCITY_TOKEN:-}" ]; then
            echo "⚠️ TeamCity configuration not available - cannot fetch detailed build errors"
            echo "Will skip detailed analysis"
          else
            echo "Fetching build problems and logs from TeamCity..."
            
            # First, try to get build IDs from downloaded artifacts (most reliable method)
            TEAMCITY_BUILD_IDS=""
            if [ -d "teamcity-build-info" ]; then
              echo "Extracting TeamCity build IDs from artifacts..."
              for BUILD_ID_FILE in teamcity-build-info/*/teamcity-build-id-*.txt; do
                if [ -f "$BUILD_ID_FILE" ]; then
                  BUILD_ID=$(cat "$BUILD_ID_FILE" 2>/dev/null || echo "")
                  PLATFORM=$(basename "$BUILD_ID_FILE" | sed 's/teamcity-build-id-//; s/\.txt//')
                  if [ -n "$BUILD_ID" ]; then
                    echo "Found TeamCity build ID for $PLATFORM: $BUILD_ID"
                    TEAMCITY_BUILD_IDS="$TEAMCITY_BUILD_IDS $BUILD_ID"
                    
                    # Also get the URL if available
                    URL_FILE="${BUILD_ID_FILE/build-id/build-url}"
                    if [ -f "$URL_FILE" ]; then
                      BUILD_URL=$(cat "$URL_FILE" 2>/dev/null || echo "")
                      if [ -n "$BUILD_URL" ]; then
                        echo "Build URL: $BUILD_URL"
                      fi
                    fi
                  fi
                fi
              done
            fi
            
            # If no build IDs found in artifacts, fall back to parsing job logs
            if [ -z "$TEAMCITY_BUILD_IDS" ]; then
              echo "No build IDs found in artifacts, falling back to job log parsing..."
              
              # Get the workflow run that triggered this auto-fix
              WORKFLOW_RUN_ID="${{ github.event.workflow_run.id }}"
              
              # Get jobs from the triggering workflow run
              JOBS_RESPONSE=$(curl -sS \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs")
              
              # Fetch job logs to extract build IDs from ALL jobs (not just failed ones)
              # The build ID is logged when the build is queued, regardless of final job status
              JOB_IDS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[] | select(.name | contains("Trigger TeamCity Build")) | .id')
              
              if [ -z "$JOB_IDS" ]; then
                echo "No TeamCity trigger jobs found, checking all jobs as fallback..."
                JOB_IDS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[].id')
              fi
              
              for JOB_ID in $JOB_IDS; do
                echo "Checking job $JOB_ID for TeamCity build IDs..."
                # Follow redirects with -L flag since GitHub Actions logs API returns a redirect
                JOB_LOGS=$(curl -sSL \
                  -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/jobs/$JOB_ID/logs" 2>/dev/null || echo "")
                
                if [ -n "$JOB_LOGS" ]; then
                  LINE_COUNT=$(echo "$JOB_LOGS" | wc -l)
                  echo "Successfully fetched logs for job $JOB_ID ($LINE_COUNT lines)"
                  
                  # Show a sample of the logs for debugging (first occurrence of "Build queued" or "build_id=")
                  SAMPLE=$(echo "$JOB_LOGS" | grep -E "Build queued|build_id=" | head -n 2 || echo "(no matching lines found)")
                  echo "Sample log lines: $SAMPLE"
                else
                  echo "Warning: Empty logs for job $JOB_ID"
                fi
                
                # Extract build IDs from logs using multiple patterns
                # Pattern 1: "✅ Build queued. ID=$BUILD_ID" (from echo statement)
                EXTRACTED_IDS=$(echo "$JOB_LOGS" | grep -oE "Build queued\. ID=[0-9]+" | grep -oE "[0-9]+" || echo "")
                
                # Pattern 2: "build_id=$BUILD_ID" (from GITHUB_OUTPUT) as fallback
                if [ -z "$EXTRACTED_IDS" ]; then
                  EXTRACTED_IDS=$(echo "$JOB_LOGS" | grep -oE "build_id=[0-9]+" | grep -oE "[0-9]+" || echo "")
                fi
                
                if [ -n "$EXTRACTED_IDS" ]; then
                  echo "Found build ID(s) from logs: $EXTRACTED_IDS"
                  TEAMCITY_BUILD_IDS="$TEAMCITY_BUILD_IDS $EXTRACTED_IDS"
                else
                  echo "No build IDs found in job $JOB_ID logs"
                fi
              done
            fi
            
            TEAMCITY_BUILD_IDS=$(echo "$TEAMCITY_BUILD_IDS" | xargs)
            echo "Found TeamCity build IDs: $TEAMCITY_BUILD_IDS"
            build_ids="$TEAMCITY_BUILD_IDS"
            
            # Fetch detailed build problems AND build logs from TeamCity for each build ID
            ALL_PROBLEMS_JSON="[]"
            ALL_LOG_ERRORS=""
            
            if [ -n "$TEAMCITY_BUILD_IDS" ]; then
              for BUILD_ID in $TEAMCITY_BUILD_IDS; do
                echo "Fetching problems and logs for TeamCity build $BUILD_ID..."
                
                # Get problemOccurrences (structured errors)
                PROBLEMS_RESPONSE=$(curl -sS \
                  -H "Authorization: Bearer $TEAMCITY_TOKEN" \
                  -H "Accept: application/json" \
                  "$TEAMCITY_URL/app/rest/builds/id:$BUILD_ID/problemOccurrences?fields=problemOccurrence(id,type,identity,details,additionalData,build(id,buildTypeId,webUrl,branchName))" 2>/dev/null || echo '{}')
                
                PROBLEM_COUNT=$(echo "$PROBLEMS_RESPONSE" | jq -r '.count // 0')
                echo "Found $PROBLEM_COUNT structured problem(s) for build $BUILD_ID"
                
                if [ "$PROBLEM_COUNT" -gt 0 ]; then
                  PROBLEMS_ARRAY=$(echo "$PROBLEMS_RESPONSE" | jq -r '.problemOccurrence // []')
                  ALL_PROBLEMS_JSON=$(echo "$ALL_PROBLEMS_JSON" | jq --argjson new "$PROBLEMS_ARRAY" '. + $new')
                  issue_type="build_failure"
                fi
                
                # Fetch actual build log (last 500 lines to capture errors)
                echo "Fetching build log for build $BUILD_ID..."
                BUILD_LOG=$(curl -sS \
                  -H "Authorization: Bearer $TEAMCITY_TOKEN" \
                  -H "Accept: text/plain" \
                  "$TEAMCITY_URL/app/rest/builds/id:$BUILD_ID/log" 2>/dev/null | tail -n 500 || echo "")
                
                if [ -n "$BUILD_LOG" ]; then
                  echo "Analyzing build log for errors..."
                  
                  # Extract compilation errors (common patterns)
                  COMPILE_ERRORS=$(echo "$BUILD_LOG" | grep -E "error:|Error:|ERROR:|fatal error:" | head -n 50 || echo "")
                  
                  # Extract linker errors
                  LINKER_ERRORS=$(echo "$BUILD_LOG" | grep -E "undefined reference|unresolved external|cannot find -l|ld returned" | head -n 20 || echo "")
                  
                  # Extract CMake errors
                  CMAKE_ERRORS=$(echo "$BUILD_LOG" | grep -E "CMake Error|CMake Warning.*Error" | head -n 20 || echo "")
                  
                  # Combine all extracted errors
                  LOG_ERRORS=""
                  if [ -n "$COMPILE_ERRORS" ]; then
                    LOG_ERRORS="${LOG_ERRORS}=== Compilation Errors ===\n${COMPILE_ERRORS}\n\n"
                  fi
                  if [ -n "$LINKER_ERRORS" ]; then
                    LOG_ERRORS="${LOG_ERRORS}=== Linker Errors ===\n${LINKER_ERRORS}\n\n"
                  fi
                  if [ -n "$CMAKE_ERRORS" ]; then
                    LOG_ERRORS="${LOG_ERRORS}=== CMake Errors ===\n${CMAKE_ERRORS}\n\n"
                  fi
                  
                  if [ -n "$LOG_ERRORS" ]; then
                    ALL_LOG_ERRORS="${ALL_LOG_ERRORS}\n\n--- Build $BUILD_ID ---\n${LOG_ERRORS}"
                    issue_type="build_failure"
                  else
                    echo "No specific error patterns found in build log"
                    # Include last 100 lines as fallback
                    FALLBACK_LOG=$(echo "$BUILD_LOG" | tail -n 100)
                    ALL_LOG_ERRORS="${ALL_LOG_ERRORS}\n\n--- Build $BUILD_ID (Last 100 lines) ---\n${FALLBACK_LOG}"
                  fi
                fi
              done
            else
              echo "No TeamCity build IDs found - falling back to job name analysis"
              # Extract build problem information from the jobs as fallback
              FAILED_JOBS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[]? | select(.conclusion == "failure") | .name' || echo "")
              
              if [ -n "$FAILED_JOBS" ]; then
                echo "Found failed jobs: $FAILED_JOBS"
                build_problems="$FAILED_JOBS"
                
                # Check for common patterns in job names
                if echo "$FAILED_JOBS" | grep -qi "linux\|windows"; then
                  echo "Detected platform-specific build failure"
                  issue_type="build_failure"
                fi
              fi
            fi
            
            # Save all problems as JSON for the next step
            if [ "$(echo "$ALL_PROBLEMS_JSON" | jq '. | length')" -gt 0 ]; then
              echo "Total structured problems collected: $(echo "$ALL_PROBLEMS_JSON" | jq '. | length')"
              build_problems="$ALL_PROBLEMS_JSON"
            fi
            
            # Save log errors
            if [ -n "$ALL_LOG_ERRORS" ]; then
              echo "Build log errors extracted successfully"
              build_log_summary=$(echo -e "$ALL_LOG_ERRORS")
            fi
          fi
          
          echo "issue_type=$issue_type" >> "$GITHUB_OUTPUT"
          echo "fix_available=$fix_available" >> "$GITHUB_OUTPUT"
          echo "build_ids=$build_ids" >> "$GITHUB_OUTPUT"
          echo "BUILD_PROBLEMS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$build_problems" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "BUILD_LOG_SUMMARY<<EOF" >> "$GITHUB_OUTPUT"
          echo "$build_log_summary" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "Build failure analysis complete"

      - name: Attempt Common Fixes
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == true
        id: fix
        shell: bash
        run: |
          echo "Checking for common fixable issues..."
          CHANGES_MADE=false
          
          # Get build problems from analyze step
          BUILD_PROBLEMS="${{ steps.analyze.outputs.BUILD_PROBLEMS }}"
          ISSUE_TYPE="${{ steps.analyze.outputs.issue_type }}"
          
          if [ -n "$BUILD_PROBLEMS" ]; then
            echo "Build problems detected:"
            echo "$BUILD_PROBLEMS"
            echo ""
            echo "Issue type: $ISSUE_TYPE"
            
            # In future: Add actual fix logic here based on issue_type
            # For now, we just recognize that errors exist
            echo "Auto-fix logic not yet implemented for detected issues"
            echo "This workflow now successfully recognizes build errors"
          else
            echo "No specific build problems to fix"
          fi
          
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

      - name: Commit and Push Fixes
        if: steps.fix.outputs.changes_made == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Auto-fix: Resolve build errors"
          git push

      - name: Comment on PR
        if: steps.pr.outputs.result != 'null' && fromJSON(steps.wait_checks.outputs.result).proceed == true
        uses: actions/github-script@v8
        with:
          script: |
            const prInfo = JSON.parse('${{ steps.pr.outputs.result }}');
            const changesMade = '${{ steps.fix.outputs.changes_made }}' === 'true';
            const issueType = '${{ steps.analyze.outputs.issue_type }}';
            const buildIds = '${{ steps.analyze.outputs.build_ids }}';
            const buildProblemsRaw = `${{ steps.analyze.outputs.BUILD_PROBLEMS }}`;
            const buildLogSummary = `${{ steps.analyze.outputs.BUILD_LOG_SUMMARY }}`;

            let body;
            if (changesMade) {
              body = '✅ Auto-fix applied. Please review the changes.';
            } else {
              // Try to parse build problems as JSON (from TeamCity)
              let buildProblems = [];
              try {
                const parsed = JSON.parse(buildProblemsRaw);
                if (Array.isArray(parsed) && parsed.length > 0) {
                  buildProblems = parsed;
                  console.log(`Parsed ${buildProblems.length} build problem(s) from TeamCity`);
                }
              } catch (e) {
                console.log('Build problems is not JSON array, treating as plain text');
              }
              
              // Extract error summary from build logs
              let logErrorSummary = '';
              if (buildLogSummary && buildLogSummary.trim() !== '') {
                console.log('Build log summary available');
                // Extract first few lines of each error section for summary
                const lines = buildLogSummary.split('\n');
                let errorLines = [];
                let inErrorSection = false;
                let errorCount = 0;
                
                for (const line of lines) {
                  if (line.includes('=== Compilation Errors ===') || 
                      line.includes('=== Linker Errors ===') || 
                      line.includes('=== CMake Errors ===')) {
                    inErrorSection = true;
                    continue;
                  }
                  if (line.includes('--- Build') && line.includes('---')) {
                    inErrorSection = false;
                    continue;
                  }
                  if (inErrorSection && line.trim() !== '' && errorCount < 10) {
                    errorLines.push(line.trim());
                    errorCount++;
                  }
                }
                
                if (errorLines.length > 0) {
                  logErrorSummary = errorLines.join('\n');
                }
              }
              
              // Build summary for Copilot
              let summary = '';
              if (logErrorSummary) {
                summary = `The TeamCity CI build has failed. Here are the key errors from the build log:\n\n`;
                summary += '```\n' + logErrorSummary + '\n```\n';
                if (buildLogSummary.split('\n').length > 15) {
                  summary += '\n*(Additional errors shown in detailed section below)*\n';
                }
              } else if (buildProblems.length > 0) {
                const errorCount = buildProblems.length;
                summary = `The TeamCity CI build has failed with ${errorCount} error${errorCount > 1 ? 's' : ''}:\n`;
                
                // Create concise summary of issues
                for (let i = 0; i < Math.min(buildProblems.length, 5); i++) {
                  const problem = buildProblems[i];
                  const problemIdentity = problem.identity || 'Unknown issue';
                  summary += `${i + 1}. ${problemIdentity}\n`;
                }
                
                if (buildProblems.length > 5) {
                  summary += `... and ${buildProblems.length - 5} more error(s)\n`;
                }
              } else if (buildProblemsRaw && buildProblemsRaw.trim() !== '') {
                summary = `The TeamCity CI build has failed. Error details are shown below.\n`;
              } else {
                summary = `The TeamCity CI build has failed but no specific error details were extracted from TeamCity.\n`;
              }
              
              // Start with Copilot-addressed message
              body = '## ❌ Build Failed\n\n';
              body += '### @github-copilot\n\n';
              body += '**Build Error Summary:**\n\n';
              body += summary;
              body += '\n';
              body += '**Request:** Please analyze these build errors and suggest specific fixes for this PR. ';
              body += 'Focus on the actual compilation/linker errors shown above.\n\n';
              body += '---\n\n';
              
              // Add full build log errors if available
              if (buildLogSummary && buildLogSummary.trim() !== '') {
                body += '### Complete Build Log Errors\n\n';
                body += '<details>\n<summary>Click to expand full build log errors</summary>\n\n';
                body += '```\n' + buildLogSummary.replace(/[\u0000-\u001F\u007F-\u009F]/g, '').trim() + '\n```\n\n';
                body += '</details>\n\n';
              }
              
              // Add structured problem information if available
              if (buildProblems.length > 0) {
                body += '### Structured Build Problems\n\n';
                body += '<details>\n<summary>Click to expand TeamCity problem occurrences</summary>\n\n';
                body += `Found ${buildProblems.length} problem${buildProblems.length > 1 ? 's' : ''} in the build:\n\n`;
                
                for (let i = 0; i < buildProblems.length; i++) {
                  const problem = buildProblems[i];
                  const problemType = problem.type || 'Unknown';
                  const problemIdentity = problem.identity || 'Unknown issue';
                  const problemDetails = problem.details || 'No details available';
                  const buildInfo = problem.build || {};
                  const buildUrl = buildInfo.webUrl || '';
                  const buildId = buildInfo.id || '';
                  
                  body += `#### Error ${i + 1}: ${problemType}\n\n`;
                  body += `**Issue:** ${problemIdentity}\n\n`;
                  
                  if (buildUrl) {
                    body += `**TeamCity Build:** [Build ${buildId}](${buildUrl})\n\n`;
                  }
                  
                  body += '**Details:**\n';
                  body += '```\n' + problemDetails + '\n```\n\n';
                  body += '---\n\n';
                }
                body += '</details>\n\n';
              } else if (buildProblemsRaw && buildProblemsRaw.trim() !== '' && !buildLogSummary) {
                // Fallback for text-based problems only if no log summary
                body += '### Build Information\n\n';
                body += '```\n' + buildProblemsRaw.replace(/[\u0000-\u001F\u007F-\u009F]/g, '').trim() + '\n```\n\n';
              }
              
              // Add links to logs and workflow
              body += '### Additional Information\n\n';
              body += `- **Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
              body += `- **Original Build Failure:** [View Build](${{ github.event.workflow_run.html_url }})\n`;
              
              if (buildIds) {
                const buildIdArray = buildIds.split(' ').filter(id => id.trim() !== '');
                for (const buildId of buildIdArray) {
                  body += `- **TeamCity Build ${buildId}:** [${{ vars.TEAMCITY_URL }}/viewLog.html?buildId=${buildId}](${{ vars.TEAMCITY_URL }}/viewLog.html?buildId=${buildId})\n`;
                }
              }
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: body
            });
