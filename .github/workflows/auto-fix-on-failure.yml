name: Auto-Fix on Build Failure

on:
  workflow_run:
    workflows: ["TeamCity CI"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto-fix:
    name: Attempt Auto-Fix
    runs-on: ubuntu-latest
    # Only run on failed builds from pull requests in the same repository (not forks)
    # This allows the workflow to run automatically without requiring approval
    if: |
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.head_repository.full_name == github.repository
    steps:
      - name: Get PR Information
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            if (pulls.data.length === 0) {
              console.log('No open PR found for this branch');
              return null;
            }
            const pr = pulls.data[0];
            console.log(`Found PR #${pr.number}: ${pr.title}`);
            return {
              number: pr.number,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref
            };

      - name: Checkout PR branch
        if: steps.pr.outputs.result != 'null'
        uses: actions/checkout@v6
        with:
          ref: ${{ fromJSON(steps.pr.outputs.result).head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Analyze Build Failure
        if: steps.pr.outputs.result != 'null'
        id: analyze
        env:
          TEAMCITY_URL: ${{ vars.TEAMCITY_URL }}
          TEAMCITY_TOKEN: ${{ vars.TEAMCITY_TOKEN }}
        shell: bash
        run: |
          echo "Analyzing build failure patterns..."
          
          # Initialize variables
          issue_type="unknown"
          fix_available="false"
          build_problems=""
          build_ids=""
          
          # Check if TeamCity configuration is available
          if [ -z "${TEAMCITY_URL:-}" ] || [ -z "${TEAMCITY_TOKEN:-}" ]; then
            echo "⚠️ TeamCity configuration not available - cannot fetch detailed build errors"
            echo "Will skip detailed analysis"
          else
            echo "Fetching build problems from TeamCity..."
            
            # Get the workflow run that triggered this auto-fix
            WORKFLOW_RUN_ID="${{ github.event.workflow_run.id }}"
            
            # Get jobs from the triggering workflow run
            JOBS_RESPONSE=$(curl -sS \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs")
            
            # Extract TeamCity build IDs from job steps
            echo "Extracting TeamCity build IDs from workflow jobs..."
            
            # Fetch job logs to extract build IDs if available
            JOB_IDS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[] | select(.conclusion == "failure") | .id')
            
            TEAMCITY_BUILD_IDS=""
            for JOB_ID in $JOB_IDS; do
              echo "Checking job $JOB_ID for TeamCity build IDs..."
              JOB_LOGS=$(curl -sS \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${{ github.repository }}/actions/jobs/$JOB_ID/logs" 2>/dev/null || echo "")
              
              # Extract build IDs from logs
              # NOTE: This pattern matches the output format from teamcity-trigger.yml line 130:
              # "✅ Build queued. ID=$BUILD_ID"
              # If the log format in teamcity-trigger.yml changes, update this pattern accordingly
              EXTRACTED_IDS=$(echo "$JOB_LOGS" | grep -oP "Build queued\. ID=\K\d+" || echo "")
              if [ -n "$EXTRACTED_IDS" ]; then
                TEAMCITY_BUILD_IDS="$TEAMCITY_BUILD_IDS $EXTRACTED_IDS"
              fi
            done
            
            TEAMCITY_BUILD_IDS=$(echo "$TEAMCITY_BUILD_IDS" | xargs)
            echo "Found TeamCity build IDs: $TEAMCITY_BUILD_IDS"
            build_ids="$TEAMCITY_BUILD_IDS"
            
            # Fetch detailed build problems from TeamCity for each build ID
            ALL_PROBLEMS_JSON="[]"
            if [ -n "$TEAMCITY_BUILD_IDS" ]; then
              for BUILD_ID in $TEAMCITY_BUILD_IDS; do
                echo "Fetching problems for TeamCity build $BUILD_ID..."
                
                PROBLEMS_RESPONSE=$(curl -sS \
                  -H "Authorization: Bearer $TEAMCITY_TOKEN" \
                  -H "Accept: application/json" \
                  "$TEAMCITY_URL/app/rest/builds/id:$BUILD_ID/problemOccurrences?fields=problemOccurrence(id,type,identity,details,additionalData,build(id,buildTypeId,webUrl,branchName))" 2>/dev/null || echo '{}')
                
                PROBLEM_COUNT=$(echo "$PROBLEMS_RESPONSE" | jq -r '.count // 0')
                echo "Found $PROBLEM_COUNT problem(s) for build $BUILD_ID"
                
                if [ "$PROBLEM_COUNT" -gt 0 ]; then
                  # Add build problems to collection
                  PROBLEMS_ARRAY=$(echo "$PROBLEMS_RESPONSE" | jq -r '.problemOccurrence // []')
                  ALL_PROBLEMS_JSON=$(echo "$ALL_PROBLEMS_JSON" | jq --argjson new "$PROBLEMS_ARRAY" '. + $new')
                  issue_type="build_failure"
                fi
              done
            else
              echo "No TeamCity build IDs found - falling back to job name analysis"
              # Extract build problem information from the jobs as fallback
              FAILED_JOBS=$(echo "$JOBS_RESPONSE" | jq -r '.jobs[]? | select(.conclusion == "failure") | .name' || echo "")
              
              if [ -n "$FAILED_JOBS" ]; then
                echo "Found failed jobs: $FAILED_JOBS"
                build_problems="$FAILED_JOBS"
                
                # Check for common patterns in job names
                if echo "$FAILED_JOBS" | grep -qi "linux\|windows"; then
                  echo "Detected platform-specific build failure"
                  issue_type="build_failure"
                fi
              fi
            fi
            
            # Save all problems as JSON for the next step
            if [ "$(echo "$ALL_PROBLEMS_JSON" | jq '. | length')" -gt 0 ]; then
              echo "Total problems collected: $(echo "$ALL_PROBLEMS_JSON" | jq '. | length')"
              build_problems="$ALL_PROBLEMS_JSON"
            fi
          fi
          
          echo "issue_type=$issue_type" >> "$GITHUB_OUTPUT"
          echo "fix_available=$fix_available" >> "$GITHUB_OUTPUT"
          echo "build_ids=$build_ids" >> "$GITHUB_OUTPUT"
          echo "BUILD_PROBLEMS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$build_problems" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "Build failure analysis complete"

      - name: Attempt Common Fixes
        if: steps.pr.outputs.result != 'null'
        id: fix
        shell: bash
        run: |
          echo "Checking for common fixable issues..."
          CHANGES_MADE=false
          
          # Get build problems from analyze step
          BUILD_PROBLEMS="${{ steps.analyze.outputs.BUILD_PROBLEMS }}"
          ISSUE_TYPE="${{ steps.analyze.outputs.issue_type }}"
          
          if [ -n "$BUILD_PROBLEMS" ]; then
            echo "Build problems detected:"
            echo "$BUILD_PROBLEMS"
            echo ""
            echo "Issue type: $ISSUE_TYPE"
            
            # In future: Add actual fix logic here based on issue_type
            # For now, we just recognize that errors exist
            echo "Auto-fix logic not yet implemented for detected issues"
            echo "This workflow now successfully recognizes build errors"
          else
            echo "No specific build problems to fix"
          fi
          
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

      - name: Commit and Push Fixes
        if: steps.fix.outputs.changes_made == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Auto-fix: Resolve build errors"
          git push

      - name: Comment on PR
        if: steps.pr.outputs.result != 'null'
        uses: actions/github-script@v8
        with:
          script: |
            const prInfo = JSON.parse('${{ steps.pr.outputs.result }}');
            const changesMade = '${{ steps.fix.outputs.changes_made }}' === 'true';
            const issueType = '${{ steps.analyze.outputs.issue_type }}';
            const buildIds = '${{ steps.analyze.outputs.build_ids }}';
            const buildProblemsRaw = `${{ steps.analyze.outputs.BUILD_PROBLEMS }}`;

            let body;
            if (changesMade) {
              body = '✅ Auto-fix applied. Please review the changes.';
            } else {
              body = '## ❌ Build Failed\n\n';
              body += 'The TeamCity CI build has failed. Below are the build errors extracted from the build logs:\n\n';
              
              // Try to parse build problems as JSON (from TeamCity)
              let buildProblems = [];
              try {
                const parsed = JSON.parse(buildProblemsRaw);
                if (Array.isArray(parsed) && parsed.length > 0) {
                  buildProblems = parsed;
                  console.log(`Parsed ${buildProblems.length} build problem(s) from TeamCity`);
                }
              } catch (e) {
                console.log('Build problems is not JSON array, treating as plain text');
              }
              
              if (buildProblems.length > 0) {
                // Display each build problem as a formatted error
                body += `### Build Errors (${buildProblems.length} problem${buildProblems.length > 1 ? 's' : ''} detected)\n\n`;
                
                for (let i = 0; i < buildProblems.length; i++) {
                  const problem = buildProblems[i];
                  const problemType = problem.type || 'Unknown';
                  const problemIdentity = problem.identity || 'Unknown issue';
                  const problemDetails = problem.details || 'No details available';
                  const buildInfo = problem.build || {};
                  const buildUrl = buildInfo.webUrl || '';
                  const buildId = buildInfo.id || '';
                  
                  body += `#### Error ${i + 1}: ${problemType}\n\n`;
                  body += `**Issue:** ${problemIdentity}\n\n`;
                  
                  if (buildUrl) {
                    body += `**TeamCity Build:** [Build ${buildId}](${buildUrl})\n\n`;
                  }
                  
                  body += '**Details:**\n';
                  body += '```\n' + problemDetails + '\n```\n\n';
                  body += '---\n\n';
                }
              } else if (buildProblemsRaw && buildProblemsRaw.trim() !== '') {
                // Fallback for text-based problems
                body += '### Build Errors\n\n';
                body += '```\n' + buildProblemsRaw.replace(/[\u0000-\u001F\u007F-\u009F]/g, '').trim() + '\n```\n\n';
              } else {
                body += '⚠️ Build failed but no specific error details were extracted from TeamCity.\n\n';
              }
              
              // Add links to logs and workflow
              body += '### Additional Information\n\n';
              body += `- **Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
              body += `- **Original Build Failure:** [View Build](${{ github.event.workflow_run.html_url }})\n`;
              
              if (buildIds) {
                body += `- **TeamCity Build IDs:** ${buildIds}\n`;
              }
              
              body += '\n**Please review the errors above and fix them in this PR.**\n';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: body
            });
